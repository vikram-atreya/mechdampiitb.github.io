---
layout: post
title:  "CS 751 - Principles of Concurrent and Parallel Programming"
categories: [insti electives]
tags: [courses]
image: assets/images/Course Reviews/Insti/cs751.png
featured: false
hidden: false
---

#### Instructor:
Prof R K Shyamasundar

#### Motivation to take this course:
After my second year summer intern, which gave me flavour of what the practical challenges of working with distributed systems could be like, & having completed the online Operating Systems course offered on Udacity, I decided to actually try and broaden by knowledge in software development by developing an intuition about working with distributed systems: the core ideas, developments over the years & some practical aspects. Hence, I took up this course on “Principles of Concurrent and Parallel Programming”.

#### Sections:
Just a single section. Very small section (~15 people) with ~40% UGs, mostly from the CS & EE Departments.

#### Semester:
Autumn ‘19

#### Course Difficulty:
This course is typically an advanced level course. Although this course initially touches upon the basics of threads & processes along with basic synchronization constructs, it is definitely a good idea to have done an OS course prior to taking this one. Grasping some advanced concepts could be tricky at times & a decent amount of time needs to be spent on reading relevant research papers (provided by the professor) & browsing through multiple reference books & online resources to develop a firm understanding of the content. Exams were typically of moderate-difficult level, but the project was pretty doable. Overall, I would rate the course difficulty as 9/10.

#### Time commitment required:
Lectures account for 3 hours per week for this course. Simply studying from class notes wasn’t of much help because the slides were very minimalistic. Around 3-4 hours per week should be devoted to review the week’s content & explore related stuff from the references & online sources. Reading the research papers provided by the instructor along with the lecture slides (or trying to figure them out from the snippets present in the slides, hunting them down & reading them) could take up another 2-3 hours weekly (but not necessary every week). So overall, 4-5 hours of weekly self study was necessary to achieve a good grade (8+) in this course.

#### Attendance Policy:
Attending classes was mandatory, with the general Institute Attendance Policy.

#### Grading Policy and Statistics:
The grading was reasonably fair, with 2 AA’s, 2 AB’s, 6 BB’s and the remaining to also follow similarly. No FRs were awarded.

#### Prerequisites:
No hard prerequisites are needed for this course, but having a decent knowledge of Operating Systems, processes, threads & synchronization constructs could ease the ramp-up process.
Knowledge of Python/Java/X10/Golang would be beneficial for completing the Course Project.

#### Evaluation Scheme:
20% Quizzes, 30% Project, 25% Midsem, 30% Endsem

#### Course Contents (in brief):
The course is meant to familiarize students with fundamentals of concurrency, including concepts like treads, critical sections, different synchronization constructs & the way to analyse algorithms for deadlocks, fairness & starvation. The course kicked off with the introduction to Guarded Commands & Nondeterminism, gradually moving towards classical synchronization problems & related concurrency & parallelism fundamentals. Students were introduced to X10 Parallel Programming Language & were expected to convert pseudocode in different notations to X10 code & vice versa by leveraging the various constructs that were mentioned throughout the course. Representations of concurrency problems using CSP & Ada were also introduced.
Post midsem, students were exposed to a multitude of applications of distributed systems including RPCs, Time Synchronization, Big Data handling using MapReduce & parallelism in GP GPUs. The last leg of the course (post quiz 2) focussed on ACID properties of distributed databases & different types of consistency that could be achieved.

#### Mechanism of Instruction and Teaching Style
The instructor used a mix of slides & whiteboard teaching during the course. Although most of the content explained on the whiteboard were present in the slides, it was still important to take down notes in class because advanced variants of some examples illustrated in class would appear in the exams. Hence, developing an intuition was crucial to extend logical arguments & make suitable assumptions while tackling a problem.
The teaching style was reasonable, but definitely not the best that one would expect. Concepts were often left unclear in the students’ minds and we had to do our own research to make sense of some content. Nevertheless, the instructor did make an effort to address doubts in class & was also pretty approachable out of class.

#### Feedback on Tutorials/Assignments/Projects etc
There were no tutorials or assignments for this course.
The course project accounted for 30% of the total score & was around designing & developing a distributed system to cater to some use cases or implement some distributed algorithms explained in a research paper. Students were provided with a list of topics to choose from (while they could also suggest their own ideas & get them verified from the instructor). Language wasn’t a boundary, but Java or X10 was preferred. A 10-min presentation + demo was expected at the end of the course based on the project including some critical analysis of the system.

#### How strongly would you recommend someone for taking this course?
This is a pretty advanced course, with some reasonable background knowledge implicitly expected. Also, given the vast amount of content covered throughout the course, it could be challenging. Hence, I would recommend this course only to those students who are enthusiastic about facing challenges, want to broaden their thinking (lots of edge & corner cases need to be tackled in a distributed environment), have a decent degree of familiarity with coding & are ready to put in a decent amount of extra effort to connect the dots mentioned in class & grasp the nuances of building large scale distributed applications.

When did you take this course? What will be the ideal semester to take this course? Any other course which can be done before this?
I took up this course in my 5th semester (Autumn ‘19). Being a pretty advanced course, I would suggest picking it up only in the 3rd, 4th or 5th year (preferably 4th or 5th year).
Doing some course on Operating Systems (CS 347 M or any online variant) thoroughly would set a great foundation to take up this course later on.

#### Feedback on Exams:
The exams were completely application-oriented & tested the understanding of the student largely. Some questions demanded careful analysis of some variants of the algorithms mentioned in class to spot the places where things could go wrong, while others involved writing code (or pseudocode) to solve some concurrency problems. One isn’t expected to get the syntax all correct if (s)he manages to get the solution idea correct. The difficulty of all the exams could be categorized as moderate-difficult and evaluation was pretty strict.

#### References used:
No fixed reference suggested by the instructor.
References used by me:
1. The Little Book of Semaphores (by Allen B. Downey)
2. An Introduction to Programming with Threads (by Andrew Birrell)
3. The Art of Multiprocessor Programming (by Maurice Herlihy and Nir Shavit)


*Review by:* Tezan Sahu
